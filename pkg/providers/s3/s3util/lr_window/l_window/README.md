# LWindow - Documentation (auto-generated by cursor)

## What is it?

`LWindow` (Left Window) is a data structure for tracking files in a processing system. The window moves **from left to right** along the `LastModifiedNS` timeline of files (e.g., in S3).

Main purpose: determine whether a file is **"new"** (requires processing) or has already been processed.

## Concept

`LWindow` uses two containers:

1. **`toHandle`** — queue of files waiting to be processed
    - Files are automatically added here when `IsNewFile()` is called
    - Files are removed from here after `Commit()`
    - Does not grow uncontrollably

2. **`handled`** — set of processed files
    - Files are added here after `Commit()`
    - Old entries are periodically cleaned up

## How does file "newness" determination work?

A file is considered **new** if:

1. ✅ File is already in `toHandle` (in processing queue)
2. ✅ `handled` is empty (cold start — all files are new)
3. ✅ File timestamp >= left border of the window (`LBorder`)

A file is considered **old** if:

1. ❌ File is already in `handled` (already processed)
2. ❌ File timestamp < left border of the window (processed long ago)

## Main Methods

### `NewLWindow(overlapDuration time.Duration, minAmountElementsInWindow int) *LWindow`

Creates a new window.

**Parameters:**
- `overlapDuration` — window overlap duration (determines how far back to keep information)
- `minAmountElementsInWindow` — minimum number of elements that must remain in the `handled` container after cleanup

### `IsNewFile(currFileNS int64, fileName string) (bool, error)`

Checks if a file is new.

**What it does:**
- Checks the file according to the rules above
- If the file is new → automatically adds it to `toHandle`
- Returns `true` if the file is new, `false` if old

**Example:**
```go
isNew, err := window.IsNewFile(1000000000, "file.txt")
if isNew {
    // File is new, needs processing
}
```

### `Commit(currFileNS int64, fileName string, listTimeDuration time.Duration) error`

Marks a file as processed.

**What it does:**
1. Removes the file from `toHandle`
2. Adds the file to `handled`
3. Performs cleanup of old entries from `handled` (if window size exceeds the allowed limit)

**Important:** On error, the object becomes invalid (no transactions).

## Cleanup of Old Entries

When the size of the processed files window exceeds `overlapDuration + listTimeDuration`, cleanup is performed:

1. **"Soft" border** (`leftSoftBorder`) is calculated — based on window size
2. **"Hard" border** (`leftStrongBorder`) is calculated — from `toHandle` (protects files in queue)
3. **Stricter border** (minimum) is chosen as `newLeftBorder`
4. Files from `handled` with timestamp less than `newLeftBorder` are removed **only if** after removal there will be more than `minAmountElementsInWindow` elements remaining

**Cleanup behavior:**
- Cleanup removes files starting from the oldest (smallest timestamp)
- Removal happens key by key (all values for a key are removed together)
- Cleanup stops when:
    - All files with timestamp < `newLeftBorder` are removed, OR
    - Removing the next key would leave ≤ `minAmountElementsInWindow` elements

This ensures that the `handled` container always maintains at least `minAmountElementsInWindow` elements (unless there are fewer elements total).

## Important Features

⚠️ **Not thread-safe** — use only from a single thread

⚠️ **No transactions** — on error, the object becomes invalid

⚠️ **No defensive checks** — calling code must guarantee:
- Object is created via constructor (fields are not `nil`)
- File names are not empty
- Timestamps >= 0

## Usage Example

```go
// Create a window with overlap duration and minimum elements threshold
window := NewLWindow(5 * time.Minute, 10) // Keep at least 10 elements after cleanup

// Check a file
isNew, err := window.IsNewFile(1000000000, "file.txt")
if err != nil {
    // Error
}

if isNew {
    // Process the file...

    // Mark as processed
    err = window.Commit(1000000000, "file.txt", 10*time.Minute)
    if err != nil {
        // Error - object is invalid
    }
}
```

**Choosing `minAmountElementsInWindow`:**
- **Small value (0-5)**: More aggressive cleanup, less memory usage, but may lose recent history
- **Medium value (10-50)**: Balanced approach, maintains recent history while preventing unbounded growth
- **Large value (100+)**: Conservative cleanup, maintains more history, uses more memory

## When to Use?

- File system monitoring (S3, local FS)
- Log processing
- Data synchronization
- Backup systems

## Conclusion

`LWindow` is a specialized structure for tracking file processing state using timestamps. Optimized for single-threaded use without excessive checks.
